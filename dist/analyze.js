// Generated by CoffeeScript 1.9.0
(function() {
  var Dictionary, Harmony, Range, Segment, WordToken, audio_analysis, d, i, lyric, pitch_names, raw_lyrics, segment, segments, token, word_tokens, _i, _len,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty;

  audio_analysis = require('./data/audio_analyses/blue_spotted_tail');

  raw_lyrics = require('./data/lyrics/blue_spotted_tail');

  pitch_names = require('./data/pitch_names');

  Range = (function() {
    function Range(_at_min, _at_max) {
      this.min = _at_min;
      this.max = _at_max;
    }

    Range.prototype.overlap = function(other_range) {
      return this.min <= other_range.max && other_range.min <= this.max;
    };

    return Range;

  })();

  WordToken = (function(_super) {
    __extends(WordToken, _super);

    function WordToken(_at_word, timestamp, next_timestamp) {
      var max, min, parse_timestamp;
      this.word = _at_word;
      parse_timestamp = function(ts) {
        var minute_string, minutes, second_string, seconds, total_seconds, _ref, _ref1;
        _ref = ts.split(":"), minute_string = _ref[0], second_string = _ref[1];
        _ref1 = [parseFloat(minute_string), parseFloat(second_string)], minutes = _ref1[0], seconds = _ref1[1];
        total_seconds = seconds + (60.0 * minutes);
        return total_seconds;
      };
      this.word = this.word.toLowerCase();
      min = parse_timestamp(timestamp);
      max = parse_timestamp(next_timestamp);
      WordToken.__super__.constructor.call(this, min, max);
    }

    return WordToken;

  })(Range);

  Segment = (function(_super) {
    __extends(Segment, _super);

    function Segment(start, duration, _at_confidence, pitches) {
      this.confidence = _at_confidence;
      this.harmony = new Harmony(pitches);
      Segment.__super__.constructor.call(this, start, start + duration);
    }

    Segment.prototype.harmony = function() {
      return this.harmony;
    };

    return Segment;

  })(Range);

  Harmony = (function() {
    function Harmony(_at_pitches) {
      this.pitches = _at_pitches;
    }

    Harmony.prototype.triad = function() {
      var highest_strengths, pitch, strength, strongest_pitches, _i, _len, _results;
      highest_strengths = this.pitches.slice(0).sort(function(a, b) {
        return b - a;
      }).slice(0, 3);
      strongest_pitches = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = highest_strengths.length; _i < _len; _i++) {
          strength = highest_strengths[_i];
          _results.push(this.pitches.indexOf(strength));
        }
        return _results;
      }).call(this);
      _results = [];
      for (_i = 0, _len = strongest_pitches.length; _i < _len; _i++) {
        pitch = strongest_pitches[_i];
        _results.push(pitch_names[pitch]);
      }
      return _results;
    };

    return Harmony;

  })();

  Dictionary = (function() {
    function Dictionary() {
      this.dic = {};
    }

    Dictionary.prototype.add = function(word_token) {
      var _base, _name;
      if ((_base = this.dic)[_name = word_token.word] == null) {
        _base[_name] = [];
      }
      return this.dic[word_token.word].push(word_token);
    };

    Dictionary.prototype.count = function(word) {
      return this.dic[word].length;
    };

    return Dictionary;

  })();

  word_tokens = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = raw_lyrics.length; _i < _len; i = ++_i) {
      lyric = raw_lyrics[i];
      if (raw_lyrics[i + 1] !== void 0) {
        _results.push(new WordToken(lyric.word, lyric.timestamp, raw_lyrics[i + 1].timestamp));
      }
    }
    return _results;
  })();

  d = new Dictionary();

  for (_i = 0, _len = word_tokens.length; _i < _len; _i++) {
    token = word_tokens[_i];
    d.add(token);
  }

  segments = (function() {
    var _j, _len1, _ref, _results;
    _ref = audio_analysis.segments;
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      segment = _ref[_j];
      _results.push(new Segment(segment.start, segment.duration, segment.confidence, segment.pitches));
    }
    return _results;
  })();

}).call(this);
